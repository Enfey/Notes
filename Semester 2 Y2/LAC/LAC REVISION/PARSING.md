> To resolve sentence into component parts of speech, describe them gramatically.

Comp sci, take this, mean answering:
$$ w \in L(G)$$ For a CFG G by analysing structure of $w$  according to $G$, i.e., to recognise members of the language generated by G.

# Parser
Program, carries out parsing. For a CFG, amount to realisation of a PDA P, which processes input string, determines if $w \in L(P)$ .
For most practical application, parser, return, structured representation of a word $w \in L(G)$. Could be derivation tree, or simplified version, AST. Practical parser provide error message. Turns tokens into structured representation for furteher analysis or execution.


# Parsing strategies
Two basic paradigms:
- Top-Down: attempts carry out derivation matching input from start symbol: construct parse tree for input from root downwards in pre-order.
- Bottom-Up: constructs parse tree from leaves using productions backwards.
Been doing top down parsing thus far when derived some word in language from **START SYMBOL** of a grammar generating that language. 

![[Pasted image 20250501004030.png]]

![[Pasted image 20250501004037.png]]

![[Pasted image 20250501004101.png]]

In contrast, bottom-up parser would start from the leaves, and step-by step group them together by applying productions in reverse???


# Recursive-Descent Parsing
Way to implement top-down parsing. Focus here just on $w \in L(G)$ 

```haskell
parser :: [Token] -> Bool
```

Consider production in CFG G$$
S \to AB
$$
$S$ can be expanded into $AB$
For any nonterminal $X$, let $L(X)$  be the language $\{w \in T^* \ | \ X \xRightarrow{*}_G w \}$ (starting from $X$ can derive $w$), Note that:
$$

\begin{array}{rll}

w \in L(S) \Leftarrow \exists w_{1},w_{2}\ \cdot & w=w_{1}w_{2} \\

 & \wedge w_{1} \in L(A) \\

 & \wedge w_{2} \in L(B)

\end{array}

$$
Given parser for L(A) and parser for L(B), can construct parser for L(S) by asking first parser if prefix $w1 \in L(A)$ and then ask second parser $w2 \in L(A)$ . If yes, then $w \in L(S)$ 

## Dividing input
Need to find right way, divide input $w$. There are generally |w| + 1 possibilities, could blindly try them al, but prefix and suffix would have to be split in all possible ways, not computationally viable. Need to let input guide the search, adopting the following idea:

- ***Each parser tries to derive a prefix of the input according to productions for the non-terminal***
- ***Each parser returns remaining suffix if successful, allowing this to be passed to next parser for analysis***
Once one parser, consumes part of input and produces suffix(remaining tokens), next parser can take that suffix and try to match its part.

**NOTE:** One parser function per nonterminal in the grammar, not per production. 

## Parser for $L(S)$ in terms of $L(A)$ and $L(B)$ and recursive nature
```haskell
parseS :: [Token] -> Maybe [Token]
parseS ts = 
	case parseA ts of 
		Nothing -> Nothing 
		Just ts' -> parseB ts'
```
Called recursive descent parsing, parse functions often mutually recursive, call each other, due to nonterminals appearing in their respective bodies e.g., A could appear in B, and would call parseA, return suffix, process again, etc. 

Fundamental to implementation of recursive computation - keeps track of state of computation, allows for subcomputations (mini mutually recursive parsers). The stack is not explicitly visible, but is a central DS, thus a recursive-descent parser is a form of **PDA.**

Let us develop the above example further:
First for simplicity, let us pick the type `Char` for token:
```haskell
type Token = Char
-- Thus [Token] = [Char]
```

Now suppose the **productions** for $A$ and $B$ are:

$$

\begin{array}{rll}

A  & \to & a \\

B & \to & b

\end{array}

$$
Here is `parseA`:

```haskell

parseA :: [Token] -> Maybe [Token]

parseA ('a' : ts) = Just ts

parseA _          = Nothing

```

And here is `parseB`:

```haskell

parseB :: [Token] -> Maybe [Token]

parseB ('b' : ts) = Just ts

parseB _          = Nothing

```

Parsing abcd, derived from A, call parse A, leaving bcd, call parse b, remaining suffix is cd.
Cannot parse abcd just using b, gives nothing
Parse abcd using just a, gives bcd.

## Handling choice
Usually more than one production for a nonterminal:
$$ S \to AB \ | \ CD$$Make the choice more obvious, assume that it is manifest from the grammar we can choose between production bodies with a one-symbol lookahead for guidance on what to choose: see below

$$

S\to aAB\mid cCD

$$


Construct parser for this grammar: 
$$\begin{array}{rll}

S & \to & aA & \mid & bBA \\

A & \to & aA & \mid & \epsilon \\

B & \to & bB & \mid & \epsilon

\end{array}$$


One parsing function, each non-terminal 
```haskell

parseS :: [Token] -> Maybe [Token]

parseA :: [Token] -> Maybe [Token]

parseB :: [Token] -> Maybe [Token]

```

**Pattern matching** makes use of one-symbol lookahead to choose between the two productions for $S$ 

```haskell
parseS :: [Token] -> Maybe [Token]
parseS ('a' : ts) =
    parseA ts
parseS ('b' : ts) =
    case parseB ts of
        Nothing  -> Nothing
        Just ts' -> parseA ts'
parseS _ = Nothing
```

If start with a, then just do parseA, and if start with b, then we do parseB and then parseA. 

For parseB and then parseA, not a syntax error if next token is not an a, as can choose empty transition. 

So both functions can succeed without consuming any input
```haskell
parseA :: [Token] -> Maybe [Token]
parseA ('a' : ts) = parseA ts 
parseA ts = Just ts --empty production

parseB :: [Token] -> Maybe [Token] 
parseB ('b' : ts) = parseB ts 
parseB ts = Just ts --empty production
```
Recognises prefix, returns suffix cannot currently parse, often to another parser, until no longer recursively called. 

### Handling choice with same lookahead token for multiple production rules
Now consider more challenging scenario:$$S\to aA\mid aBA$$
In the parsing function **parseS** for nonterminal $S$, should **parseA** or **parseB** be called once $a$ has been read?

Could try the alternatives in order:
```haskell
parseS ('a' : ts) =
    case parseA ts of
        Just ts' -> Just ts'
        Nothing  ->
            case parseB ts of
                Nothing  -> Nothing
                Just ts' -> parseA ts'
```
If parse A succeeds, simply parse, if it doesn't, then try parseB, if that works, then try A again with returned suffix. 
The choice to try parseA first is arbitrary here.
LIMITED FORM OF BACKTRACKING.

Above works for this example, for other CFGs this will not work. This is because our limited backtracking, not exhaustive.

For many grammars, no-one order that will always work and will recognise $w \in L(G)$ meaning that a parser that commits to one particular order, gets stuck in blind alley, cannot derive, when $w \in L(G)$ really. 

$$

\begin{array}{rll}

S & \to & AB \\

A & \to & aA & \mid & \epsilon \\

B & \to & ab

\end{array}

$$
Try this grammar:

Corresponding parser functions:
```haskell
parseA ('a' : ts) = parseA ts
parseA ts = Just ts 

parseB ('a' : 'b' : ts) = Just ts 
parseB ts = Nothing

parseS ts = 
	case parseA ts of 
		Nothing -> Nothing 
		Just ts' -> parseB ts'
```

$$

S \to AB\to B\to ab

$$
Try this, clearly in language. Fails, A consumes A, returns b, then parseb runs, which fails, looks for a, which has already been consumed. Should've chosen empty production at A. Parse A committed too early and never tried $A \to \epsilon$ 

If did $A \to epsilon$ would work, but then parser would fail to recognise words like aab. To successsfully parse that word, parseA must somehow consume the first a, but not the second, neither ordering of the productions will achieve that? i guess

One principled approach, try all alternatives, full backtracking

## Full Backtracking
Each parsing function, return list of possible suffixes instead of just choosing one, check if input string is in that list of strings, then it is able to be parsed. 

Translate $A \to a \ \ | \ \beta$  into
```haskell
parseA ts = parseAlpha ts ++ parseBeta ts
```

Computationally expensive, and in error report, difficult to pinpoint exact location of syntax error: where lies problem if only after exhaustive search, apparent no way to parse that word?


## Recursive Descent parsing and left-recursion
Consider the grammar $$ A \to Aa \ \ | \ \ \epsilon$$
and the corresponding recursive-descent parsing function:
```haskell
parseA :: [Token] -> Maybe [Token] 
parseA ts = 
	case parseA ts of 
		Just ('a' : ts') -> Just ts' 
		_ -> Just ts
```
This will call itself without consuming any input, it will just loop forever, as the grammar is left-recursive. 
Cannot deal with LEFT RECURSIVE GRAMMARS. Must transform to one that is not left recursive, and then derive parser.

## Predictive Parsing 
In recursive descent parsing, we want a parsing function to be **successful exactly when a prefix of the input can be derived from corresponding nonterminal.** Achieved by:
- Adopting suitable parsing strategy, specifically regarding choice of productions
- Impose restrictions on the grammar to ensure success of chosen parsing strategy
**Predictive parsing** is when all parsing decisions can be made based on **lookahead of limited length**, typically one symbol. See cases, predictive parsing, possible. Manifestly, case when RHS of each possible production, starts with distinct terminal, know which to apply. 

$$ S \to \ aB \ | \ cD$$
Now look into exactly when next input symbol is sufficient to make all choices. As a result, if faced with grammar where one lookahead not enough, can rectify this, transform the grammar again.

$$

\begin{array}{rll}

S & \to & AB & \mid & CD \\

A & \to & a & \mid & b \\

C & \to & c & \mid  & d

\end{array}

$$
If starts with a or b, should try AB, if starts with c or d, should try CD clearly. TO know which production to pick for a nonterminal then, must first figure out, all possible symbols, that could appear at very front of any string nonterminal can generate. Called **first set.**

GOAL:
> We want each parsing function for a nonterminal $X$ to succeed exactly when the next part of the input to pass to $X'$ can be derived from $X$ and to fail otherwise - without backtracking.
> 

More generally consider productions for a nonterminal $X$ $$ X \to a \ | \ \beta$$

and the corresponding parser:
```haskell
parseX (t : ts) = 
	| t ?? -> parseAlpha
	| t ?? -> parseBeta
	| otherwise -> Nothing
```

IDEA OF PREDICTIVE PARSING:
- Compute first set
- If there is a choice between two or more alternatives, insist that the first sets are disjoint (restriction)
- The righ choice can now be made simply by determining to which first set input symbol belongs

```haskell
parseX (t : ts) = 
	| t ∈ firstSet(alpha) -> parseAlpha
	| t ∈ firstSet(beta) -> parseBeta
	| otherwise -> Nothing
```

However, possible to derive empty word from nonterminal, which doesnt begin with any symbol at all. Assume $\beta \xRightarrow{*} \epsilon$ . Ambiguity,  `t` is not in `first(β)`— $\beta$ might be skipped entirely. Clearly, the next input symbol could be a terminal that can follow a string derivable from $X$ 

```haskell
parseX (t : ts) = 
	| t ∈ firstSet(alpha) -> parseAlpha
	| t ∈ firstSet(beta) ∪ follow(X)  -> parseBeta
	| otherwise -> Nothing
```


### First and follow sets
For a **CFG** $G$ = $(N, T, P, S)$:$$

\begin{array}{rll}

first(\alpha) & = & \{ a \in T\mid\alpha \Rightarrow_{G}^*a\beta \} \\

follow(A) & = & \{ a \in T \mid S \Rightarrow_{G}^*\alpha Aa\beta \}

 \cup \{ $ \ |S \Rightarrow_{G}^*\alpha A \}

\end{array}

$$
First set: First set of $a$ is the set of **terminals** where $a$ can derive a string that beings with a.

Follow set: Follow set of a nonterminal $A$ consists of all terminals that can appear immediately after $A$ in some derivation from the **start symbol.** End of input marker $\$ \in follow(A)$ if there exists a derivation where $A$ appears at the end of a string derived from $S$. 

(reason for alpha and beta in follow set shows that there may be more stuff prior to the A and a.)

To illustrate:
$$

\begin{array}{rll}

S & \to & ABC \\

A & \to & aA  & \mid & \epsilon \\

B & \to & b & \mid & \epsilon \\

C & \to & c & \mid & d

\end{array}

$$

The **first** sets are:

$$

\begin{array}{rll}

first(C) & = & \{ c,d \} \\

first(B) & = & \{ b \} \\

first(A) & = & \{ a \}  \\

first(S) & = & first(ABC) \\

 & = & \left[ \text{because }A \Rightarrow^* \epsilon \text{ and }B \Rightarrow^* \epsilon \right]  \\

 &  & first(A) \cup first(B) \cup first(C) \\

 & = & \{ a,b,c,d \}

\end{array}

$$

The **follow** sets are:

$$

\begin{array}{rll}

follow(C) & = & \{ $ \} \\

follow(B) & = & first(C)=\{ c,d \} \\

follow(A) & = & \left[ \text{because }B \Rightarrow^* \epsilon \right] \\

&& first(B) \cup first(C) \\

&=& \{ b,c,d \}

\end{array}

$$


Must both be sets of terminals



# LL(1) Grammars
Now consider $all$ productions for a nonterminal $A$ in some grammar: $$A \ \to a_n \ | \ a_2 \ | \ ... \  | \ a_n$$
In parsing function for $A$, on input symbol $t$, we should parse according to $a_i$ if
- $t \in first(a_i)$ 
- $t \in follow(A)$, if $\ a_i \Rightarrow^* \epsilon$ 
DO IT ACCORDING TO FIRST SET, OR IF ITS IN FOLLOW SET IF PRODUCTION CAN DERIVE EMPTY WORD.


Conditions:
1. $first(\alpha_{i})\cap first(\alpha_{j})=\emptyset$ for $i \neq j$ 
2.  If $\alpha_{i}\Rightarrow^*\epsilon$ for some $i$, then, for all $j \neq i$,
	    - $\alpha_{j}\not\Rightarrow^*\epsilon$ and $follow(A)\cap first(\alpha_{j})=\emptyset$
		    - WHY? IF a_i \rightarrow \epsilon, parser may choose A \to \epsilon based on t \in follow(A), but if in another frst set, have ambiguity.
		   - IF A SYMBOL IS IN THE FOLLOW SET FOR SOME PRODUCTION WHICH CAN DERIVE EMPTY WORD, CANNOT BE IN ANY FIRST SETS FOR ANY PRODUCTION EXCEPT THAT ONE. 

SOME CONTEXT FREE LANGUAGES CANNOT BE GENERATED BY ANY LL(1) GRAMMAR

## Nullable non-terminals
![[Pasted image 20250522012549.png]]
![[Pasted image 20250522012626.png]]
Look for epsilon, work backwards.

## Picking prefixes.
There could be more than one prefix derivable from a non-terminal, how do we know which one to pick, picking wrong one might make it impossible for following parser to correctly derive given suffix. 



# Questions
S → AB
A → aA | ε
B → bBc | ε
## Nullable nonterminals
b is nullable
a is nullable
s is nullable
## First set
A = {a}
B = {b}
S = {a, b}

## Follow set
B = {$}
A = {b, $}
S = {$}

