# Symbol management
Linker key function, encompassing symbol binding and resolving - process in which reference in one module to another module is resolved to machine address.

Sheaf of tables compiler maintains e.g., type checking, is flattened. Compiler emits only externally visible symbols, potentially function-level symbols for debugging. ELF `.symtab` thus flat, and global at file level with no sub tables. 

## Binding and Name resolution
Linkers handle variety of kinds of symbols.

### Symbol types
- Global symbols defined and referenced
- Global symbols referenced but not defined in module(externals)
- Segment/section names, considered to be global symbols defined to be at beginning of segment
	- These exist in ELF, every section can have corresponding symbol with:
		- `st_name = 0`
		- `st_info: STB_Local && STT_SECTION`
		- `st_shndx` points to that section
		- Their purpose is to allow relocation entries to refer to specific sections. 
- Nonglobal/function-level symbols, debugging/crash dump analysis
- Line number information.
Read all symbol tables in input modules, extract necessary info, build link-time symbol tables, use those to guide linking process. 

Depending on output format, may place some/all of symbol information in the output file. 

Some formats such as ELF can have multiple symbol tables per file. ELF shared libraries can have one symbol table for dynamic linker, and separate larger table for debugging and relinking. 

## Symbol Table Formats
Linker symbol table generally similar to those generated by compiler. 
Generally maintain a few distinct symbol tables
- One lists the input files and library modules
- One handles global symbols, the ones the linker has to resolve among input files
- One may debugging symbols, often case that full table not needed for debug symbols however, just pass through to output file. 

### Generic Symbol Table Scheme
Coalesced, in-memory symbol table for a linker is essentially hash table with separate chaining collision resolution mechanism. Each 'hash header' points to a linked list of symbols that hash to same value. 

To locate a symbol in table:
1. `hash(symname) = hashval`
2. `bucket = hashval % NBUCKET`
3. Traverse linked list `symhash[bucket]`
4. Compare names and other properties until a hash is found
```C
struct sym *symhash[NBUCKET]; //array of length NBUCKET containg sym elements

struct sym {
	struct sym *next;
	int         fullhash;
	char        *symname;  // string derived from st_name
}
```

`strcmp` for each symbol in a bucket is expensive, C++ produce long, mangled names, comparison becomes expensive, especially with poor distribution. 

Optimisation, compute pre-modulo hash value, for each symbol in chain, compare stored hash val, if matches, then do `strcmp`. 

### Module Tables
Linker, need track every input module seen during linking run. Both explicitly linked, and linked from libraries. Module table handles this. Most files, key info in headers, so table stores copy of the header. 

Immediate version below is forerunner to methodology employed by modern linkers, but still essential. 

Each module table entry represents one input file, holding roughly the following kind of data. 

| Field                       | Description                                                                                   |
| --------------------------- | --------------------------------------------------------------------------------------------- |
| Header                      | A copy of the a.out file header, gives sizes and addresses of .text, .data, .bss, and tables. |
| Symbol Table Pointer        | Pointer to in-memory copy of the symbol table.                                                |
| String Table Pointer        | Pointer to the in-memory copy of symbol names.                                                |
| Relocation Table Pointer(s) | For .text and .data relocation entries.                                                       |
| Computed output offsets     | The positions of this module's text/data/bss in final output file after storage allocation.   |
| Flags                       | Indicate if the module was pulled from library, has unresolved symbols etc.                   |
| Next/previous pointers      | Chain modules together.                                                                       |

Table used as follows:
First pass:
	For each input file, read file header and symbol table
	Create new module table entry
	Copy symbol table, string table, relocations, into memory

Second pass:
	Walk through all module table entries
	Resolve definitions and references
	If undefined global symbol found and can be satisfied by library member, read in library member, creating new module table entry, beginning from first pass.

Third pass:
	Linker assigns output addresses to each module's sections
	Update computed offset fields in each module table entry

Fourth pass:
	Apply relocations. 

A primitive definition is provided below

```C
typedef struct Module {
    AOutHeader header;          // copy of a.out file header
    Symbol *symtab;            // pointer to in-memory symbol table
    char *strings;              // pointer to in-memory string table
    Reloc *text_relocs;         // relocations for .text
    Reloc *data_relocs;         // relocations for .data
    long text_offset;           // output offset for .text
    long data_offset;           // output offset for .data
    long bss_offset;            // output offset for .bss
    struct Module *next;        // next module in list
} Module;
```

### Custom ELF module table
No single equivalent. Internal data structures that suit needs of modern ELF can be developed to function as a module table.

A construction for 32 bit ELF is provided below:

```C
#include <stdint.h>
#include <stdlib.h>

/*----------------------------------------------------------
 ELF32 type aliases (replicating <elf.h>)
----------------------------------------------------------*/

typedef uint32_t Elf32_Addr;    // 4 bytes
typedef uint32_t Elf32_Off;     // 4 bytes
typedef uint16_t Elf32_Half;    // 2 bytes
typedef uint32_t Elf32_Word;    // 4 bytes
typedef int32_t  Elf32_Sword;   // 4 bytes

/*----------------------------------------------------------
  Linker internal data structures
----------------------------------------------------------*/

/* Global symbol entry */
typedef struct {
    char     *name;
    Symbol   *definition;      // resolved definition
    Symbol   **references;     // list of unresolved uses
    uint32_t num_refs;
} GlobalSymbol;

/* Relocation entry */
typedef struct Relocation {
    Elf32_Addr  offset;
    Elf32_Word  type;        
    Symbol     *symbol;      // referenced symbol
    Elf32_Sword addend;      // relocation addend
} Relocation;

/* Symbol Entry */
typedef struct Symbol {
	char         *name;
	Elf32_Addr   st_value;   // Offset within section
	InputSection *section; 
	uint8_t      size;
    uint8_t      binding;    // STB_LOCAL, STB_GLOBAL, etc.
    uint8_t      type;       // STT_FUNC, STT_OBJECT, etc.
    uint8_t      visibility;
    GlobalSymbol *resolved; // resolving definition 
} Symbol;

/* Section */
typedef struct InputSection {
	char       *name;
	Elf32_Word *data;       // raw section contents
	Elf32_Word size;
	Elf32_Word alignment;
	Elf32_Addr vaddr;
	Elf32_Off  offset;
	
	Relocation **relocations;
	Elf32_Word num_relocations;
	Elf32_Word flags;
	Elf32_Word type;
} InputSection; 

/* InputObject */
typedef struct InputObject {
	char       *objname;
	Section    **sections;    // double = flexible free
	Symbol     **symbols;     // double = flexible free
	Elf32_Word num_sections
	Elf32_Word num_symbols;
} InputObject;
```
#### Usage

##### 1. Parsing
1. **Parse ELF file header**
	Use `ELF32_Ehdr` to locate **section header table** and `.symtab`
	Allocate `InputObject` and other data structures.
2. **Parse general sections**
	For each section in section header table:
	- Allocate `InputSection` and populate values
3. **Parse symbols**
	For each entry in `.symtab`
	- Allocate a `Symbol` and populate values
		- `section` null if `st_shndx == NULL`
		- `resolved` null by default
4. **Parse Relocations**
	For each entry in `.rel/a{name}
	- Allocate `Relocation` and populate values
		- `*symbol` can be assigned, `.symtab` parsed
		- Note: either need a 'backwards pointer' or must look for `{name}` in `InputObject` to set `**relocations` in `InputSection`
##### 2.  Name Resolution
1. **Build *GST* visible to all modules:**
	For each input `Symbol`
		`binding` $\in$ `{STB_GLOBAL, STB_WEAK}` -> insert or update in GST
		Mark undefined symbols as unresolved, `definition == null`
##### 3. Storage Allocation
##### 4. Applying relocations