# What are Object files?
Compilers + assemblers create object files containing the generated binary code and data, and metadata for a given source file. Linkers combine multiple object files into one file; loaders take coalesced object files and load them into memory. There are many object file formats.

## What Goes into an object file?
Contains 5 kinds of basic info(can contain more, but this is minimum usually). 
1. *Header Information*: Overall metadata for file e.g., size of the code, name of source file translated from, and creation date.
2. *Object Code* - Binary/Hex instructions and data generated by a compiler or assembler
3. *Relocation Information* - list of places in object code that need to be modified that need to be modified when linker assigns new addresses to the object code
4. *Symbols* - These include global symbols defined in this module and symbols to be imported from other modules or defined by the linker.
5. *Debugging Information* - this information is not required for linking but is useful to a debugger. Includes info such as source file and line number information, local symbols and descriptions of data structures used by the object code e.g., C struct definitions.

### Designing an Object Format
Design is a compromise driven by the use case of a given object file.
1. A file may be **linkable**, used as input by a link editor or linking loader
	A linkable file contains extensive symbol and relocation information needed by linker along with the object code. The object code is often divided up into many small logical segments that will be treated differently by the linker.
2. A file may be **executable**, capable of being loaded into memory and run as a program
	An executable file contains object code - usually page aligned to permit the file to be mapped into physical address space - but doesn't need any symbol info unless doing run-time dynamic linking, little or no relocation info too. The object code is a single large segment or small set of segments that directly reflect the hardware execution environment (most often read only vs read/write pages).
3. A file may be **loadable**, capable as being loaded into memory as a library along with a program.
	Depending on details of a systems runtime environment, a loadable file may consist solely of object code, or it may contain complete symbol and relocation information to permit run-time linking. 
Amongst these applications, there is conflict. For example, the logically oriented grouping of linkable file segments rarely matches the hardware oriented grouping of executable segments, which prioritises separating read-only code from read-write data pages to save on I/O cycles. 


### DOS COM - The Null Object Format
The DOS COM format is characterised by its extreme simplicity, consisting of literally nothing other that runnable binary code. It contrasts with other formats by having little or no information beyond the object code. The design of the .COM format relies on the segmented architecture of the x86 processor. 

When the OS runs a COM file, it merely loads the contents into a chunk of free memory starting always starting at offset 0x100 from the segment base (0-FF are reserved, and hold command line args and other parameters). 

The system also sets all x86 segment registers (code segment, data segment) to point to the base of the Program Segment Prefix, which occupies the addresses 0-FF. The stack pointer is set to the highest usable address in the segment to accommodate the downward-growing stack. 

We need no relocation, as the program addresses are interpreted as offsets relative to the segments, which are all aligned to the base address of the PSP. Although this leads to an issue in that .COM is only suitable for programs that will fit in a single segment as it uses the tiny model. If a program exceeds this size, it became the programmers responsibilities for performing any necessary address fixups. E.g., identify target address, and substitute the original single instruction with an intermediate table lookup or sequence of instructions to construct full 32 bit address.
### Unix A.Out Files
More traditional object file format used on Unix systems. It is associated with systems that create a new process with an empty address space, thus programs can be linked to start at a fixed address and require no relocation at load time. 

In the simplest case, an $a.out$ file consists of a **small header** followed by the executable code, traditionally called the text section, and initial values for static data. 

$\text{Not Relevant, but interesting}$:

Historically, PDP had only 16 bit addressing, 64KB program size limit, became too small, so later models provided separate address spaces for code (I for instruction space) and data (d space), contain 64KB of code, and 64KB of data. Compilers, assemblers, and linker modified to create two-section object files, with code located in first section, and data in second section; program loader loaded first section into process's I space and second into the D space. 

Separate I and D spaces had another performance advantage, as program couldn't change its own I space, could share a single copy of program code while keeping separate copies of the program's data. On a timeshare system like UNIX, multiple copies of the shell and network daemons are common, shared program code thus saved considerable memory. Only 286 and 386 still use separate addressing for code and data. Now use shared read-only code pages in conjunction with shared memory, much more efficient. Means that linker formats at least mark read-only versus read-write sections to enable better frame/page backing (UNIX confusingly calls file sections segments, so use that term during the duration of UNIX file formats.)

#### Header of an A.Out file
The header somewhat varies from one version of UNIX to another, but the version in BSD UNIX is typical:
$$
\begin{gathered}
\text{int a\_magic //magic number} \\
\text{int a\_text //text segment size} \\
\text{int a\_data //initialised data size}  \\
\text{int a\_bss //uninitialised data size} \\
\text{int a\_syms //symbol table size} \\
\text{int a\_entry //entry point} \\
\text{int a\_trsize //text relocation size} \\
\text{int a\_drsize//data relocation size} \\
\end{gathered}
$$
The magic number $a\_magic$ indicates what kind of executable file this is. Different magic numbers tell the OS to load the file into memory differently.

The text and segment sizes $a\_text$ and $a\_data$ are the sizes in bytes of the read only code and read/write data that follow the header. Because UNIX automatically initialises newly allocated memory to zero, any data with an initial content of 0 or whose contents don't matter need not be present in the $a.out$ file. 

The $a\_entry$ field gives the starting address of the program, while $a\_syms, a\_trsize,$ and $a\_drsize$ specify how much symbol table and relocaiton information follows the data segment/section in the file. Programs that have been linked and are ready to run need neither symbol nor relocation information, so these fields are zero in runnable files barring symbols for the debugger. 

#### Interactions with virtual memory : NMAGIC, ZMAGIC, QMAGIC
The process involved when the OS loads and starts a simple 2 segment a.out file is straightforward:
1. Read the a.out header to get the segment sizes
2. Check to see if there's already a shareable code segment for this file. If so, map that segment into the process's address space. If not, create one, and map the text segment from the program into the process's address space. 
3. Create a private data segment large enough for the combined data and bss, map it into the process, and read the data segment from the file into the data segment. Zero out the bss segment. Place directly after text segment, not page-aligned. 
4. Create and map in a stack segment, often at top address of process as stack grows downward. Place arguments from the command line or the calling program on the stack.
5. Set registers appropriately and jump to the starting address. 
![[Pasted image 20251024192610.png]]
This scheme is known as NMAGIC, and was used until paging became prevalent.

When say map here, don't mean true file mapping, more so actual copying. 

##### ZMAGIC
Improvement to NMAGIC to leverage virtual memory and paging capabilities, and enable file mapping. ZMAGIC structural changes included the requirement of segments to be aligned on page boundaries:
- The a.out header is expanded to match a page size
- The text segments size is rounded up to the next page boundary
- The data segment size does not need rounding up as the BSS segment logically follows the data segment and is zeroed by the program loader anyway.
Because the a.out file is already stored on disk itself, the object file can be mapped into the process's address space.

OS allocates virtual address space for the program according to header size info. Instead of copying the programs content immediately, uses a.out file as paging disk i.e., backing store with on-demand paging. Marks pages in mapped segments as not present, so page faults generated, page faults handled by paging system by backing up pages with the necessary 4KB aligned chunks of the file on disk, moving them into corresponding physical page frames. Text pages mapped as read-only, data mapped as copy-on-write.

Speeds up program startup, and reduce unneeded paging, but does it at cost of wasting memory space. The gap between text and data often wastes 2KB on average, and the header is only 32 bytes long but expanded to be page aligned and separate from the text section, so is further wasting roughly 4KB.
![[Pasted image 20251024195659.png]]


##### QMAGIC
Compact pageable format developed to overcome the drawback of ZMAGIC wasting disk and memory space due to expanded headers and padding. 

The QMAGIC format optimises space and safety via specific loading and structural conventions. Considers the header to be part of the text segment. 

The kernel maps the program into memory such that the header + beginning of text segment are mapped starting at virtual address $page\_size$, leaving the first virtual page unmapped, letting null pointer dereference trigger a fault instead of landing in mapped code/data. This is the key change from zmagic, other than considering the header to be part of the text segment, and also rounding up the data segment to a full page, so the system can easily memory map file chunks to virtual address space pages.

The last page of the data segment is padded out with zeros for bss data; if more bss data exists than fits in the padding area, the header contains the size of the remaining bss area to allocate. 

The header is used to create the logical address space and enforce constraints e.g., the first page will remain unmapped in QMAGIC. Then when the program starts, page faults are generated and the paging system enforces demand paging for the chunks of the file, and memory maps the file into the physical frames for the corresponding pages!

### DOS EXE Files
The a.out format is adequate for systems that assign a fresh, private logical address space to each process as it assumes a program is linked to load at one fixed virtual address. 

### Relocatable a.out










### ELF files



